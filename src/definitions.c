/********************************************************************************************
 *    _ ____  ___             _         _     ___              _                        _
 *   (_)__ / | _ \_ _ ___  __| |_  _ __| |_  |   \ _____ _____| |___ _ __ _ __  ___ _ _| |_
 *   | ||_ \ |  _/ '_/ _ \/ _` | || / _|  _| | |) / -_) V / -_) / _ \ '_ \ '  \/ -_) ' \  _|
 *   |_|___/ |_| |_| \___/\__,_|\_,_\__|\__| |___/\___|\_/\___|_\___/ .__/_|_|_\___|_||_\__|
 *                                                                  |_|
 *                           -----------------------------------
 *                          Copyright i3 Product Development 2023
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * \brief A minimal implementation of Reach data access.  Auto-generated by a Python script.
 *
 * Original Author: Chuck Peplinski
 * Script Author: Joseph Peplinski
 *
 * Generated with version 0.0.1 of c_code_generator.py
 *
 ********************************************************************************************/

#include "definitions.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "i3_log.h"
#include "app_version.h"
#include "cr_stack.h"

const cr_DeviceInfoResponse device_info = 
{
    .device_name        = "nRF52840 Dongle",
    .manufacturer       = "Nordic Semiconductor",
    .device_description = "A demo of Reach features",
    .protocol_version   = cr_ReachProtoVersion_CURRENT_VERSION,
    .services           = cr_ServiceIds_PARAMETER_REPO | cr_ServiceIds_FILES | cr_ServiceIds_COMMANDS | cr_ServiceIds_CLI | cr_ServiceIds_TIME
};

cr_ParameterValue sCr_param_val[NUM_PARAMS];

cr_ParameterInfo param_desc[NUM_PARAMS] = {
    {
        .id                = PARAM_USER_DEVICE_NAME,
        .name              = "User Device Name",
        .which_desc        = cr_ParameterDataType_STRING + cr_ParameterInfo_uint32_desc_tag,
        .desc.string_desc.has_default_value = true,
        .desc.string_desc.default_value = "Test",
        .desc.string_desc.has_max_size = true,
        .desc.string_desc.max_size = 26,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "Advertised BLE name",
    },
    {
        .id                = PARAM_TIMEZONE_ENABLED,
        .name              = "Timezone Mode",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .desc.bool_desc.has_default_value = true,
        .desc.bool_desc.default_value     = true,
        .desc.bool_desc.has_off_text = true,
        .desc.bool_desc.off_text = "Non-timezoned",
        .desc.bool_desc.has_on_text = true,
        .desc.bool_desc.on_text = "Timezoned",
    },
    {
        .id                = PARAM_TIMEZONE_OFFSET,
        .name              = "Timezone Offset",
        .which_desc         = cr_ParameterDataType_INT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "The offset from UTC",
        .desc.int32_desc.has_units = true,
        .desc.int32_desc.units             = "seconds",
        .desc.int32_desc.has_range_min     = true,
        .desc.int32_desc.range_min         = -43200,
        .desc.int32_desc.has_default_value = true,
        .desc.int32_desc.default_value     = 0,
        .desc.int32_desc.has_range_max     = true,
        .desc.int32_desc.range_max         = 43200,
    },
    {
        .id                = PARAM_BT_DEVICE_ADDRESS,
        .name              = "BT Device Address",
        .which_desc         = cr_ParameterDataType_BYTE_ARRAY + cr_ParameterInfo_uint32_desc_tag,
        .desc.bytearray_desc.has_max_size = true,
        .desc.bytearray_desc.max_size     = 6,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    },
    {
        .id                = PARAM_UPTIME,
        .name              = "Uptime",
        .which_desc         = cr_ParameterDataType_INT64 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .desc.int64_desc.has_units = true,
        .desc.int64_desc.units             = "milliseconds",
    },
    {
        .id                = PARAM_BUTTON_PRESSED,
        .name              = "Momentary Pushbutton",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.has_off_text = true,
        .desc.bool_desc.off_text = "Not Pressed",
        .desc.bool_desc.has_on_text = true,
        .desc.bool_desc.on_text = "Pressed",
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    },
    {
        .id                = PARAM_IDENTIFY_LED_ON,
        .name              = "Identify LED",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.has_off_text = true,
        .desc.bool_desc.off_text = "Off",
        .desc.bool_desc.has_on_text = true,
        .desc.bool_desc.on_text = "On",
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    },
    {
        .id                = PARAM_RGB_LED_STATE,
        .name              = "RGB LED State",
        .which_desc        = cr_ParameterDataType_BIT_FIELD + cr_ParameterInfo_uint32_desc_tag,
        .desc.bitfield_desc.has_bits_available = true,
        .desc.bitfield_desc.bits_available = 3,
        .desc.bitfield_desc.has_definition_id = true,
        .desc.bitfield_desc.definition_id = 1,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Reset on disconnection",
    },
    {
        .id                = PARAM_RGB_LED_COLOR,
        .name              = "RGB LED Color",
        .which_desc         = cr_ParameterDataType_ENUMERATION + cr_ParameterInfo_uint32_desc_tag,
        .desc.enum_desc.has_definition_id = true,
        .desc.enum_desc.definition_id = 0,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Reset on disconnection",
    },
    {
        .id                = PARAM_IDENTIFY,
        .name              = "Identify",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.has_off_text = true,
        .desc.bool_desc.off_text = "Not Identifying",
        .desc.bool_desc.has_on_text = true,
        .desc.bool_desc.on_text = "Identifying",
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Blinks the green LED",
    },
    {
        .id                = PARAM_IDENTIFY_INTERVAL,
        .name              = "Identify Interval",
        .which_desc         = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "Time between Identify blinks",
        .desc.float32_desc.has_units = true,
        .desc.float32_desc.units             = "seconds",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = 0.01,
        .desc.float32_desc.has_default_value = true,
        .desc.float32_desc.default_value     = 1,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 60,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 2,
    }
};

cr_ParamExInfoResponse param_ex_desc[NUM_EX_PARAMS] = {
    {
        .enum_bitfield_id = 0,
        .data_type = cr_ParameterDataType_ENUMERATION,
        .enums_bits_count = 8,
        .enums_bits = {
            {RGB_LED_COLOR_OFF,     "Off"},
            {RGB_LED_COLOR_RED,     "Red"},
            {RGB_LED_COLOR_GREEN,   "Green"},
            {RGB_LED_COLOR_YELLOW,  "Yellow"},
            {RGB_LED_COLOR_BLUE,    "Blue"},
            {RGB_LED_COLOR_MAGENTA, "Magenta"},
            {RGB_LED_COLOR_CYAN,    "Cyan"},
            {RGB_LED_COLOR_WHITE,   "White"}
        }
    },
    {
        .enum_bitfield_id = 1,
        .data_type = cr_ParameterDataType_BIT_FIELD,
        .enums_bits_count = 3,
        .enums_bits = {
            {RGB_LED_STATE_BIT_INDEX_RED,   "Red"},
            {RGB_LED_STATE_BIT_INDEX_GREEN, "Green"},
            {RGB_LED_STATE_BIT_INDEX_BLUE,  "Blue"}
        }
    }
};

cr_FileInfo file_descriptions[NUM_FILES] = {
    {
        .file_id            = FILE_OTA_BIN,
        .file_name          = "ota.bin",
        .current_size_bytes = 458240,
        .access             = cr_AccessLevel_WRITE,
        .storage_location   = cr_StorageLocation_NONVOLATILE,
    },
    {
        .file_id            = FILE_IO_TXT,
        .file_name          = "io.txt",
        .current_size_bytes = 512,
        .access             = cr_AccessLevel_READ_WRITE,
        .storage_location   = cr_StorageLocation_NONVOLATILE,
    },
    {
        .file_id            = FILE_CYGNUS_REACH_LOGO_PNG,
        .file_name          = "cygnus-reach-logo.png",
        .current_size_bytes = 17900,
        .access             = cr_AccessLevel_READ,
        .storage_location   = cr_StorageLocation_NONVOLATILE,
    }
};

cr_CommandInfo command_desc[NUM_COMMANDS] = {
    {
        .id   = COMMAND_REBOOT,
        .name = "Reboot",
    },
    {
        .id   = COMMAND_RESET_DEFAULTS,
        .name = "Reset Defaults",
    },
    {
        .id   = COMMAND_INVALIDATE_OTA_IMAGE,
        .name = "Invalidate OTA Image",
    },
    {
        .id   = COMMAND_CLICK_FOR_WISDOM,
        .name = "Click for Wisdom",
    }
};

// The stack will call this function.
// The const copy of the basis in flash is copied to RAM so that the device
// can overwrite varying data like SN and hash.
int crcb_device_get_info(const cr_DeviceInfoRequest *request, cr_DeviceInfoResponse *pDi)
{
    (void) request;
    // The app owns the memory here.
    // The address is returned so that the data can come from flash.
    // memcpy as the structure copy imposes a further address alignment requirement.
    // *pDi = device_info;
    memcpy(pDi, &device_info, sizeof(cr_DeviceInfoResponse));
    I3_LOG(LOG_MASK_REACH, "%s: %s\n", __FUNCTION__, device_info.device_name);

    sprintf(pDi->firmware_version, "%d.%d.%d", APP_MAJOR_VERSION, APP_MINOR_VERSION, APP_PATCH_VERSION);

    snprintf(pDi->device_name, REACH_DEVICE_NAME_LEN, "%s", cr_get_advertised_name());
    return 0;
}

void init_param_repo()
{
    int rval = 0;
    rval = app_handle_param_repo_pre_init();
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
    memset(sCr_param_val, 0, sizeof(sCr_param_val));
    for (int i=0; i<NUM_PARAMS; i++)
    {
        sCr_param_val[i].parameter_id = param_desc[i].id;

        // the PID directly maps to the parameter type, just to make it easy.
        switch ((param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag))
        {
        case cr_ParameterDataType_UINT32:
            if (param_desc[i].desc.uint32_desc.has_default_value)
                sCr_param_val[i].value.uint32_value = param_desc[i].desc.uint32_desc.default_value;
            break;
        case cr_ParameterDataType_INT32:
            if (param_desc[i].desc.int32_desc.has_default_value)
                sCr_param_val[i].value.sint32_value = param_desc[i].desc.int32_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            if (param_desc[i].desc.float32_desc.has_default_value)
                sCr_param_val[i].value.float32_value = param_desc[i].desc.float32_desc.default_value;
            break;
        case cr_ParameterDataType_UINT64:
            if (param_desc[i].desc.uint64_desc.has_default_value)
                sCr_param_val[i].value.uint64_value = param_desc[i].desc.uint64_desc.default_value;
            break;
        case cr_ParameterDataType_INT64:
            if (param_desc[i].desc.int64_desc.has_default_value)
                sCr_param_val[i].value.sint64_value = param_desc[i].desc.int64_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            if (param_desc[i].desc.float64_desc.has_default_value)
                sCr_param_val[i].value.float64_value = param_desc[i].desc.float64_desc.default_value;
            break;
        case cr_ParameterDataType_BOOL:
            if (param_desc[i].desc.bool_desc.has_default_value)
                sCr_param_val[i].value.bool_value = param_desc[i].desc.bool_desc.default_value;
            break;
        case cr_ParameterDataType_STRING:
            if (param_desc[i].desc.string_desc.has_default_value)
            {
                memset(sCr_param_val[i].value.string_value, 0, sizeof(sCr_param_val[i].value.string_value));
                memcpy(sCr_param_val[i].value.string_value, param_desc[i].desc.string_desc.default_value, sizeof(param_desc[i].desc.string_desc.default_value));
            }
            break;
        case cr_ParameterDataType_ENUMERATION:
            if (param_desc[i].desc.enum_desc.has_default_value)
                sCr_param_val[i].value.enum_value = param_desc[i].desc.enum_desc.default_value;
            break;
        case cr_ParameterDataType_BIT_FIELD:
            if (param_desc[i].desc.bitfield_desc.has_default_value)
                sCr_param_val[i].value.bitfield_value = param_desc[i].desc.bitfield_desc.default_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            if (param_desc[i].desc.bytearray_desc.has_default_value)
            {
                sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.default_value.size;
                memcpy(sCr_param_val[i].value.bytes_value.bytes, param_desc[i].desc.bytearray_desc.default_value.bytes, sizeof(param_desc[i].desc.bytearray_desc.default_value.bytes));
            }
            else
            {
                if (param_desc[i].desc.bytearray_desc.has_max_size)
                    sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.max_size;
                else
                    sCr_param_val[i].value.bytes_value.size = sizeof(sCr_param_val[i].value.bytes_value.size);
                memset(sCr_param_val[i].value.bytes_value.bytes, 0, sCr_param_val[i].value.bytes_value.size);
            }
            break;
        default:
            affirm(0);  // should not happen.
            break;
        }  // end switch

        // Convert from description type identifier to value type identifier
        sCr_param_val[i].which_value = (param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag) + cr_ParameterValue_uint32_value_tag;

        if (param_desc[i].storage_location == cr_StorageLocation_STORAGE_LOCATION_INVALID || param_desc[i].storage_location > cr_StorageLocation_NONVOLATILE_EXTENDED)
        {
          I3_LOG(LOG_MASK_ERROR, "At param index %d, invalid storage location %d.",
                 i, param_desc[i].storage_location);
        }

        rval = app_handle_param_repo_init(&sCr_param_val[i], &param_desc[i]);
        if (rval != 0)
            I3_LOG(LOG_MASK_ERROR, "At param index %d, failed to initialize data (error %d)", i, rval);

    } // end for
    rval = app_handle_param_repo_post_init();
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
}

// Populate a parameter value structure
int crcb_parameter_read(const uint32_t pid, cr_ParameterValue *data)
{
    affirm(data != NULL);
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_PARAMETER;
    int rval = app_handle_param_repo_read(&sCr_param_val[pid]);
    *data = sCr_param_val[pid];
    return rval;
}

int crcb_parameter_write(const uint32_t pid, const cr_ParameterValue *data)
{   
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_PARAMETER;
    int rval = 0;
    I3_LOG(LOG_MASK_PARAMS, "Write param, pid %d (%d)", pid, data->parameter_id);
    I3_LOG(LOG_MASK_PARAMS, "  timestamp %d", data->timestamp);
    I3_LOG(LOG_MASK_PARAMS, "  which %d", data->which_value);
    rval = app_handle_param_repo_write((cr_ParameterValue *) data);
    if (rval != 0)
    {
        // Invalid data or NVM storage failed
        return rval;
    }
    sCr_param_val[pid].timestamp = data->timestamp;
    sCr_param_val[pid].which_value = data->which_value;

    switch ((data->which_value - cr_ParameterValue_uint32_value_tag))
    {
        case cr_ParameterDataType_UINT32:
            sCr_param_val[pid].value.uint32_value = data->value.uint32_value;
            break;
        case cr_ParameterDataType_INT32:
            sCr_param_val[pid].value.sint32_value = data->value.sint32_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            sCr_param_val[pid].value.float32_value = data->value.float32_value;
            break;
        case cr_ParameterDataType_UINT64:
            sCr_param_val[pid].value.uint64_value = data->value.uint64_value;
            break;
        case cr_ParameterDataType_INT64:
            sCr_param_val[pid].value.sint64_value = data->value.sint64_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            sCr_param_val[pid].value.float64_value = data->value.float64_value;
            break;
        case cr_ParameterDataType_BOOL:
            sCr_param_val[pid].value.bool_value = data->value.bool_value;
            break;
        case cr_ParameterDataType_STRING:
            memcpy(sCr_param_val[pid].value.string_value,
                   data->value.string_value, REACH_PVAL_STRING_LEN);
            sCr_param_val[pid].value.string_value[REACH_PVAL_STRING_LEN-1] = 0;
            I3_LOG(LOG_MASK_PARAMS, "String value: %s",
                   sCr_param_val[pid].value.string_value);
            break;
        case cr_ParameterDataType_BIT_FIELD:
            sCr_param_val[pid].value.bitfield_value = data->value.bitfield_value;
            break;
        case cr_ParameterDataType_ENUMERATION:
            sCr_param_val[pid].value.enum_value = data->value.enum_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            memcpy(sCr_param_val[pid].value.bytes_value.bytes,
                   data->value.bytes_value.bytes, 
                   REACH_PVAL_BYTES_LEN);
            if (data->value.bytes_value.size > REACH_PVAL_BYTES_LEN)
            {
                LOG_ERROR("Parameter write of bytes has invalid size %d > %d",
                          data->value.bytes_value.size, REACH_PVAL_BYTES_LEN);
                sCr_param_val[pid].value.bytes_value.size = REACH_PVAL_BYTES_LEN;
            }
            else
            {
                sCr_param_val[pid].value.bytes_value.size = data->value.bytes_value.size;
            }
            LOG_DUMP_MASK(LOG_MASK_PARAMS, "bytes value",
                          sCr_param_val[pid].value.bytes_value.bytes,
                          sCr_param_val[pid].value.bytes_value.size);
            break;
        default:
            LOG_ERROR("Parameter write which_value %d not recognized.", 
                          data->which_value);
            rval = 1;
            break;
    }  // end switch
    return rval;
}

// return a number that changes if the parameter descriptions have changed.
uint32_t crcb_compute_parameter_hash(void)
{
    // Note that the layout of the structure param_desc differs by compiler.
    // The hash computed on windows won't match that computed on SiLabs.
    uint32_t *ptr = (uint32_t*)param_desc;
    // char *cptr = (char*)param_desc;
    size_t sz = sizeof(param_desc)/(sizeof(uint32_t));
    // LOG_DUMP_MASK(LOG_MASK_PARAMS, "Raw Params", cptr, sizeof(param_desc));

    uint32_t hash = ptr[0];
    for (size_t i= 1; i<sz; i++)
        hash ^= ptr[i];

#ifdef NUM_EX_PARAMS
    ptr = (uint32_t*)param_ex_desc;
    size_t sz1 = sizeof(param_ex_desc)/(sizeof(uint32_t));

    for (size_t i= 0; i<sz1; i++)
        hash ^= ptr[i];

    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d+%d = %d words.\n",
           __FUNCTION__, hash, sz, sz1, sz+sz1);
#else
    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d words.\n",
           __FUNCTION__, hash, sz);
#endif // NUM_EX_PARAMS

    return hash;
}

static int sCurrentParameter = 0;

// Gets the parameter description for the next parameter.
// Allows the stack to iterate through the parameter list.
// The caller provides a cr_ParameterInfo containing string pointers that will be overwritten.
// The app owns the string pointers which must not be on the stack.
int crcb_parameter_discover_next(cr_ParameterInfo *ppDesc)
{
    if (sCurrentParameter >= NUM_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: sCurrentParameter (%d) >= NUM_PARAMS (%d)",
               __FUNCTION__, sCurrentParameter, NUM_PARAMS);
        return cr_ErrorCodes_NO_DATA;
    }
    *ppDesc = param_desc[sCurrentParameter];
    sCurrentParameter++;
    return 0;
}


int crcb_parameter_get_count()
{
    return NUM_PARAMS;
}
// Resets the application's pointer into the parameter table such that
// the next call to crcb_parameter_discover_next() will return the
// description of this parameter.
int crcb_parameter_discover_reset(const uint32_t pid)
{
    if (pid >= NUM_PARAMS)
    {
        sCurrentParameter = 0;
        I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset defaults to %d", pid, sCurrentParameter);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }
    sCurrentParameter = pid;
    I3_LOG(LOG_MASK_PARAMS, "dp reset to %d", sCurrentParameter);
    int i;
    sCurrentParameter = 0;  // in case none match
    for (i = 0; i < NUM_PARAMS; i++)
    {
        if (param_desc[i].id == pid) {
            sCurrentParameter = i;
            I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset to %d", pid, sCurrentParameter);
            return 0;
        }
    }
    I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset defaults to %d", pid, sCurrentParameter);
    return cr_ErrorCodes_INVALID_PARAMETER;
}

// In parallel to the parameter discovery, use this to find out 
// about enumerations and bitfields
static int sCurrentExParam = 0;
static int sRequestedParamPid = -1; // negative means all

int crcb_parameter_ex_get_count(const int32_t pid)
{
#ifdef NUM_EX_PARAMS
    if (pid < 0)  // all 
        return NUM_EX_PARAMS;

    int num_ex_msgs = 0;

    for (int i=0; i<NUM_EX_PARAMS; i++) {
        if ((int32_t)param_ex_desc[i].enum_bitfield_id == pid) {
            num_ex_msgs++;
        }
    }
    return num_ex_msgs;
#else
    return 0;
#endif // NUM_EX_PARAMS
}

int crcb_parameter_ex_discover_reset(const int32_t pid)
{
    // unlike the full params, reset of param_ex always goes to zero.
    sCurrentExParam = 0;
    sRequestedParamPid = pid;
    return 0;
}

int crcb_parameter_ex_discover_next(cr_ParamExInfoResponse *pDesc)
{
    affirm(pDesc);
    pDesc->enums_bits_count = 0;
#ifdef NUM_EX_PARAMS
    if (sCurrentExParam>=NUM_EX_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params.", __FUNCTION__);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }

    if (sRequestedParamPid < 0)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: For all, return param_ex %d.", __FUNCTION__, sCurrentExParam);
        *pDesc = param_ex_desc[sCurrentExParam];
        sCurrentExParam++;
        return 0;
    }

    for (int i=sCurrentExParam; i<NUM_EX_PARAMS; i++)
    {
        if ((int32_t)param_ex_desc[i].enum_bitfield_id == sRequestedParamPid)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: For pid %d, return param_ex %d.",
                   __FUNCTION__, sRequestedParamPid, sCurrentExParam);
            *pDesc = param_ex_desc[i];
            sCurrentExParam = i+1;;
            return 0;
        }
    }
    // should not get here.
    I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params 2.", __FUNCTION__);
#endif // NUM_EX_PARAMS
    return cr_ErrorCodes_INVALID_PARAMETER;
}

int crcb_file_get_description(uint32_t fid, cr_FileInfo *file_desc)
{
    if (fid > NUM_FILES)
        return cr_ErrorCodes_BAD_FILE;
    *file_desc = file_descriptions[fid];
    return 0;
}

int crcb_file_get_file_count()
{
    return NUM_FILES;
}

static uint8_t sFid_index = 0;
int crcb_file_discover_reset(const uint8_t fid)
{
    if (fid > NUM_FILES)
    {
        I3_LOG(LOG_MASK_ERROR, "crcb_file_discover_reset(%d): invalid FID, using 0.", fid);
        sFid_index = 0;
        return cr_ErrorCodes_BAD_FILE;
    }
    sFid_index = fid;
    return 0;
}

int crcb_file_discover_next(cr_FileInfo *file_desc)
{
    if (sFid_index >= NUM_FILES)
    {
        I3_LOG(LOG_MASK_WARN, "%s: sFid_index (%d) >= NUM_FILES (%d)",
               __FUNCTION__, sFid_index, NUM_FILES);
        return cr_ErrorCodes_NO_DATA;
    }
    *file_desc = file_descriptions[sFid_index];
    sFid_index++;
    return 0;
}


uint8_t sCommandIndex = 0;

int crcb_get_command_count()
{
    return NUM_COMMANDS;
}

int crcb_command_discover_next(cr_CommandInfo *cmd_desc)
{
    if (sCommandIndex >= NUM_COMMANDS)
    {
        I3_LOG(LOG_MASK_REACH, "%s: Command index %d indicates discovery complete.",
               __FUNCTION__, sCommandIndex);
        return cr_ErrorCodes_NO_DATA;
    }
    *cmd_desc = command_desc[sCommandIndex++];
    return 0;
}

int crcb_command_discover_reset(const uint32_t cid)
{
    if (cid >= NUM_COMMANDS)
    {
        i3_log(LOG_MASK_ERROR, "%s: Command ID %d does not exist.",
               __FUNCTION__, cid);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }
    sCommandIndex = cid;
    return 0;
}

int __attribute__((weak)) app_handle_param_repo_pre_init(void)
{
    return 0;
}
int __attribute__((weak)) app_handle_param_repo_init(cr_ParameterValue *data, cr_ParameterInfo *desc)
{
    (void) desc;
    return app_handle_param_repo_read(data);
}

int __attribute__((weak)) app_handle_param_repo_post_init(void)
{
    return 0;
}

int __attribute__((weak)) app_handle_param_repo_read(cr_ParameterValue *data)
{
    (void) data;
    return 0;
}

int __attribute__((weak)) app_handle_param_repo_write(cr_ParameterValue *data)
{
    (void) data;
    return 0;
}